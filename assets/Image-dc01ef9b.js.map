{"version":3,"file":"Image-dc01ef9b.js","sources":["../../node_modules/ol/reproj/common.js","../../node_modules/ol/reproj/Triangulation.js","../../node_modules/ol/reproj.js","../../node_modules/ol/resolution.js","../../node_modules/ol/reproj/Image.js","../../node_modules/ol/source/common.js","../../node_modules/ol/source/Image.js"],"sourcesContent":["/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport const ERROR_THRESHOLD = 0.5;\n","/**\n * @module ol/reproj/Triangulation\n */\nimport {\n  boundingExtent,\n  createEmpty,\n  extendCoordinate,\n  getArea,\n  getBottomLeft,\n  getBottomRight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n  intersects,\n} from '../extent.js';\nimport {getTransform} from '../proj.js';\nimport {modulo} from '../math.js';\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source Source.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target Target.\n */\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nconst MAX_SUBDIVISION = 10;\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nconst MAX_TRIANGLE_WIDTH = 0.25;\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nclass Triangulation {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection.\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent to triangulate.\n   * @param {import(\"../extent.js\").Extent} maxSourceExtent Maximal source extent that can be used.\n   * @param {number} errorThreshold Acceptable error (in source units).\n   * @param {?number} destinationResolution The (optional) resolution of the destination.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    maxSourceExtent,\n    errorThreshold,\n    destinationResolution\n  ) {\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.sourceProj_ = sourceProj;\n\n    /**\n     * @type {import(\"../proj/Projection.js\").default}\n     * @private\n     */\n    this.targetProj_ = targetProj;\n\n    /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n    let transformInvCache = {};\n    const transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n    /**\n     * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n     * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n     * @private\n     */\n    this.transformInv_ = function (c) {\n      const key = c[0] + '/' + c[1];\n      if (!transformInvCache[key]) {\n        transformInvCache[key] = transformInv(c);\n      }\n      return transformInvCache[key];\n    };\n\n    /**\n     * @type {import(\"../extent.js\").Extent}\n     * @private\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n    /**\n     * @type {Array<Triangle>}\n     * @private\n     */\n    this.triangles_ = [];\n\n    /**\n     * Indicates that the triangulation crosses edge of the source projection.\n     * @type {boolean}\n     * @private\n     */\n    this.wrapsXInSource_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.canWrapXInSource_ =\n      this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.sourceWorldWidth_ = this.sourceProj_.getExtent()\n      ? getWidth(this.sourceProj_.getExtent())\n      : null;\n\n    /**\n     * @type {?number}\n     * @private\n     */\n    this.targetWorldWidth_ = this.targetProj_.getExtent()\n      ? getWidth(this.targetProj_.getExtent())\n      : null;\n\n    const destinationTopLeft = getTopLeft(targetExtent);\n    const destinationTopRight = getTopRight(targetExtent);\n    const destinationBottomRight = getBottomRight(targetExtent);\n    const destinationBottomLeft = getBottomLeft(targetExtent);\n    const sourceTopLeft = this.transformInv_(destinationTopLeft);\n    const sourceTopRight = this.transformInv_(destinationTopRight);\n    const sourceBottomRight = this.transformInv_(destinationBottomRight);\n    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n    /*\n     * The maxSubdivision controls how many splittings of the target area can\n     * be done. The idea here is to do a linear mapping of the target areas\n     * but the actual overall reprojection (can be) extremely non-linear. The\n     * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256\n     * tile size. However this function is also called to remap canvas rendered\n     * layers which can be much larger. This calculation increases the maxSubdivision\n     * value by the right factor so that each 256x256 pixel area has\n     * MAX_SUBDIVISION divisions.\n     */\n    const maxSubdivision =\n      MAX_SUBDIVISION +\n      (destinationResolution\n        ? Math.max(\n            0,\n            Math.ceil(\n              Math.log2(\n                getArea(targetExtent) /\n                  (destinationResolution * destinationResolution * 256 * 256)\n              )\n            )\n          )\n        : 0);\n\n    this.addQuad_(\n      destinationTopLeft,\n      destinationTopRight,\n      destinationBottomRight,\n      destinationBottomLeft,\n      sourceTopLeft,\n      sourceTopRight,\n      sourceBottomRight,\n      sourceBottomLeft,\n      maxSubdivision\n    );\n\n    if (this.wrapsXInSource_) {\n      let leftBound = Infinity;\n      this.triangles_.forEach(function (triangle, i, arr) {\n        leftBound = Math.min(\n          leftBound,\n          triangle.source[0][0],\n          triangle.source[1][0],\n          triangle.source[2][0]\n        );\n      });\n\n      // Shift triangles to be as close to `leftBound` as possible\n      // (if the distance is more than `worldWidth / 2` it can be closer.\n      this.triangles_.forEach((triangle) => {\n        if (\n          Math.max(\n            triangle.source[0][0],\n            triangle.source[1][0],\n            triangle.source[2][0]\n          ) -\n            leftBound >\n          this.sourceWorldWidth_ / 2\n        ) {\n          const newTriangle = [\n            [triangle.source[0][0], triangle.source[0][1]],\n            [triangle.source[1][0], triangle.source[1][1]],\n            [triangle.source[2][0], triangle.source[2][1]],\n          ];\n          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[0][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[1][0] -= this.sourceWorldWidth_;\n          }\n          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {\n            newTriangle[2][0] -= this.sourceWorldWidth_;\n          }\n\n          // Rarely (if the extent contains both the dateline and prime meridian)\n          // the shift can in turn break some triangles.\n          // Detect this here and don't shift in such cases.\n          const minX = Math.min(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          const maxX = Math.max(\n            newTriangle[0][0],\n            newTriangle[1][0],\n            newTriangle[2][0]\n          );\n          if (maxX - minX < this.sourceWorldWidth_ / 2) {\n            triangle.source = newTriangle;\n          }\n        }\n      });\n    }\n\n    transformInvCache = {};\n  }\n\n  /**\n   * Adds triangle to the triangulation.\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @private\n   */\n  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {\n    this.triangles_.push({\n      source: [aSrc, bSrc, cSrc],\n      target: [a, b, c],\n    });\n  }\n\n  /**\n   * Adds quad (points in clock-wise order) to the triangulation\n   * (and reprojects the vertices) if valid.\n   * Performs quad subdivision if needed to increase precision.\n   *\n   * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n   * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n   * @private\n   */\n  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n    const sourceCoverageX = this.sourceWorldWidth_\n      ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_\n      : null;\n    const sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n    // when the quad is wrapped in the source projection\n    // it covers most of the projection extent, but not fully\n    const wrapsX =\n      this.sourceProj_.canWrapX() &&\n      sourceCoverageX > 0.5 &&\n      sourceCoverageX < 1;\n\n    let needsSubdivision = false;\n\n    if (maxSubdivision > 0) {\n      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n        const targetQuadExtent = boundingExtent([a, b, c, d]);\n        const targetCoverageX =\n          getWidth(targetQuadExtent) / this.targetWorldWidth_;\n        needsSubdivision =\n          targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n        needsSubdivision =\n          sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;\n      }\n    }\n\n    if (!needsSubdivision && this.maxSourceExtent_) {\n      if (\n        isFinite(sourceQuadExtent[0]) &&\n        isFinite(sourceQuadExtent[1]) &&\n        isFinite(sourceQuadExtent[2]) &&\n        isFinite(sourceQuadExtent[3])\n      ) {\n        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n          // whole quad outside source projection extent -> ignore\n          return;\n        }\n      }\n    }\n\n    let isNotFinite = 0;\n\n    if (!needsSubdivision) {\n      if (\n        !isFinite(aSrc[0]) ||\n        !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) ||\n        !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) ||\n        !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) ||\n        !isFinite(dSrc[1])\n      ) {\n        if (maxSubdivision > 0) {\n          needsSubdivision = true;\n        } else {\n          // It might be the case that only 1 of the points is infinite. In this case\n          // we can draw a single triangle with the other three points\n          isNotFinite =\n            (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +\n            (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +\n            (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +\n            (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);\n          if (\n            isNotFinite != 1 &&\n            isNotFinite != 2 &&\n            isNotFinite != 4 &&\n            isNotFinite != 8\n          ) {\n            return;\n          }\n        }\n      }\n    }\n\n    if (maxSubdivision > 0) {\n      if (!needsSubdivision) {\n        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n        const centerSrc = this.transformInv_(center);\n\n        let dx;\n        if (wrapsX) {\n          const centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n              modulo(cSrc[0], sourceWorldWidth)) /\n            2;\n          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);\n        } else {\n          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n        }\n        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n        const centerSrcErrorSquared = dx * dx + dy * dy;\n        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n      }\n      if (needsSubdivision) {\n        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n          // split horizontally (top & bottom)\n          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n          const bcSrc = this.transformInv_(bc);\n          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n          const daSrc = this.transformInv_(da);\n\n          this.addQuad_(\n            a,\n            b,\n            bc,\n            da,\n            aSrc,\n            bSrc,\n            bcSrc,\n            daSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            da,\n            bc,\n            c,\n            d,\n            daSrc,\n            bcSrc,\n            cSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n        } else {\n          // split vertically (left & right)\n          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n          const abSrc = this.transformInv_(ab);\n          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n          const cdSrc = this.transformInv_(cd);\n\n          this.addQuad_(\n            a,\n            ab,\n            cd,\n            d,\n            aSrc,\n            abSrc,\n            cdSrc,\n            dSrc,\n            maxSubdivision - 1\n          );\n          this.addQuad_(\n            ab,\n            b,\n            c,\n            cd,\n            abSrc,\n            bSrc,\n            cSrc,\n            cdSrc,\n            maxSubdivision - 1\n          );\n        }\n        return;\n      }\n    }\n\n    if (wrapsX) {\n      if (!this.canWrapXInSource_) {\n        return;\n      }\n      this.wrapsXInSource_ = true;\n    }\n\n    // Exactly zero or one of *Src is not finite\n    // The triangles must have the diagonal line as the first side\n    // This is to allow easy code in reproj.s to make it straight for broken\n    // browsers that can't handle diagonal clipping\n    if ((isNotFinite & 0xb) == 0) {\n      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n    }\n    if ((isNotFinite & 0xe) == 0) {\n      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);\n    }\n    if (isNotFinite) {\n      // Try the other two triangles\n      if ((isNotFinite & 0xd) == 0) {\n        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);\n      }\n      if ((isNotFinite & 0x7) == 0) {\n        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);\n      }\n    }\n  }\n\n  /**\n   * Calculates extent of the `source` coordinates from all the triangles.\n   *\n   * @return {import(\"../extent.js\").Extent} Calculated extent.\n   */\n  calculateSourceExtent() {\n    const extent = createEmpty();\n\n    this.triangles_.forEach(function (triangle, i, arr) {\n      const src = triangle.source;\n      extendCoordinate(extent, src[0]);\n      extendCoordinate(extent, src[1]);\n      extendCoordinate(extent, src[2]);\n    });\n\n    return extent;\n  }\n\n  /**\n   * @return {Array<Triangle>} Array of the calculated triangles.\n   */\n  getTriangles() {\n    return this.triangles_;\n  }\n}\n\nexport default Triangulation;\n","/**\n * @module ol/reproj\n */\nimport {\n  containsCoordinate,\n  createEmpty,\n  extend,\n  forEachCorner,\n  getCenter,\n  getHeight,\n  getTopLeft,\n  getWidth,\n} from './extent.js';\nimport {createCanvasContext2D, releaseCanvas} from './dom.js';\nimport {getPointResolution, transform} from './proj.js';\nimport {solveLinearSystem} from './math.js';\n\nlet brokenDiagonalRendering_;\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * This draws a small triangle into a canvas by setting the triangle as the clip region\n * and then drawing a (too large) rectangle\n *\n * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle\n * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.\n * @param {number} v1 The y-coordinate of the second point.\n * @param {number} u2 The x-coordinate of the third point.\n * @param {number} v2 The y-coordinate of the third point.\n */\nfunction drawTestTriangle(ctx, u1, v1, u2, v2) {\n  ctx.beginPath();\n  ctx.moveTo(0, 0);\n  ctx.lineTo(u1, v1);\n  ctx.lineTo(u2, v2);\n  ctx.closePath();\n  ctx.save();\n  ctx.clip();\n  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));\n  ctx.restore();\n}\n\n/**\n * Given the data from getImageData, see if the right values appear at the provided offset.\n * Returns true if either the color or transparency is off\n *\n * @param {Uint8ClampedArray} data The data returned from getImageData\n * @param {number} offset The pixel offset from the start of data.\n * @return {boolean} true if the diagonal rendering is broken\n */\nfunction verifyBrokenDiagonalRendering(data, offset) {\n  // the values ought to be close to the rgba(210, 0, 0, 0.75)\n  return (\n    Math.abs(data[offset * 4] - 210) > 2 ||\n    Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2\n  );\n}\n\n/**\n * Determines if the current browser configuration can render triangular clip regions correctly.\n * This value is cached so the function is only expensive the first time called.\n * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976\n * Chrome works, and everything seems to work on OSX and Android. This function caches the\n * result. I suppose that it is conceivably possible that a browser might flip modes while the app is\n * running, but lets hope not.\n *\n * @return {boolean} true if the Diagonal Rendering is broken.\n */\nfunction isBrokenDiagonalRendering() {\n  if (brokenDiagonalRendering_ === undefined) {\n    const ctx = createCanvasContext2D(6, 6, canvasPool);\n    ctx.globalCompositeOperation = 'lighter';\n    ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';\n    drawTestTriangle(ctx, 4, 5, 4, 0);\n    drawTestTriangle(ctx, 4, 5, 0, 5);\n    const data = ctx.getImageData(0, 0, 3, 3).data;\n    brokenDiagonalRendering_ =\n      verifyBrokenDiagonalRendering(data, 0) ||\n      verifyBrokenDiagonalRendering(data, 4) ||\n      verifyBrokenDiagonalRendering(data, 8);\n    releaseCanvas(ctx);\n    canvasPool.push(ctx.canvas);\n  }\n\n  return brokenDiagonalRendering_;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(\n  sourceProj,\n  targetProj,\n  targetCenter,\n  targetResolution\n) {\n  const sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  let sourceResolution = getPointResolution(\n    targetProj,\n    targetResolution,\n    targetCenter\n  );\n\n  const targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  const sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    const compensationFactor =\n      getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n      sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceExtentResolution(\n  sourceProj,\n  targetProj,\n  targetExtent,\n  targetResolution\n) {\n  const targetCenter = getCenter(targetExtent);\n  let sourceResolution = calculateSourceResolution(\n    sourceProj,\n    targetProj,\n    targetCenter,\n    targetResolution\n  );\n\n  if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n    forEachCorner(targetExtent, function (corner) {\n      sourceResolution = calculateSourceResolution(\n        sourceProj,\n        targetProj,\n        corner,\n        targetResolution\n      );\n      return isFinite(sourceResolution) && sourceResolution > 0;\n    });\n  }\n\n  return sourceResolution;\n}\n\n/**\n * @typedef {Object} ImageExtent\n * @property {import(\"./extent.js\").Extent} extent Extent.\n * @property {import('./DataTile.js').ImageLike} image Image.\n */\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation Calculated triangulation.\n * @param {Array<ImageExtent>} sources Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean} [renderEdges] Render reprojection edges.\n * @param {boolean} [interpolate] Use linear interpolation when resampling.\n * @param {boolean} [drawSingle] Draw single source images directly without stitchContext.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(\n  width,\n  height,\n  pixelRatio,\n  sourceResolution,\n  sourceExtent,\n  targetResolution,\n  targetExtent,\n  triangulation,\n  sources,\n  gutter,\n  renderEdges,\n  interpolate,\n  drawSingle\n) {\n  const context = createCanvasContext2D(\n    Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height),\n    canvasPool\n  );\n\n  if (!interpolate) {\n    context.imageSmoothingEnabled = false;\n  }\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  function pixelRound(value) {\n    return Math.round(value * pixelRatio) / pixelRatio;\n  }\n\n  context.globalCompositeOperation = 'lighter';\n\n  const sourceDataExtent = createEmpty();\n  sources.forEach(function (src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  let stitchContext;\n  if (!drawSingle || sources.length !== 1 || gutter !== 0) {\n    const canvasWidthInUnits = getWidth(sourceDataExtent);\n    const canvasHeightInUnits = getHeight(sourceDataExtent);\n    stitchContext = createCanvasContext2D(\n      Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution),\n      Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution),\n      canvasPool\n    );\n\n    if (!interpolate) {\n      stitchContext.imageSmoothingEnabled = false;\n    }\n\n    const stitchScale = pixelRatio / sourceResolution;\n\n    sources.forEach(function (src, i, arr) {\n      const xPos = src.extent[0] - sourceDataExtent[0];\n      const yPos = -(src.extent[3] - sourceDataExtent[3]);\n      const srcWidth = getWidth(src.extent);\n      const srcHeight = getHeight(src.extent);\n\n      // This test should never fail -- but it does. Need to find a fix the upstream condition\n      if (src.image.width > 0 && src.image.height > 0) {\n        stitchContext.drawImage(\n          src.image,\n          gutter,\n          gutter,\n          src.image.width - 2 * gutter,\n          src.image.height - 2 * gutter,\n          xPos * stitchScale,\n          yPos * stitchScale,\n          srcWidth * stitchScale,\n          srcHeight * stitchScale\n        );\n      }\n    });\n  }\n  const targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function (triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    const source = triangle.source;\n    const target = triangle.target;\n    let x0 = source[0][0],\n      y0 = source[0][1];\n    let x1 = source[1][0],\n      y1 = source[1][1];\n    let x2 = source[2][0],\n      y2 = source[2][1];\n    // Make sure that everything is on pixel boundaries\n    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);\n    const v0 = pixelRound(\n      -(target[0][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);\n    const v1 = pixelRound(\n      -(target[1][1] - targetTopLeft[1]) / targetResolution\n    );\n    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);\n    const v2 = pixelRound(\n      -(target[2][1] - targetTopLeft[1]) / targetResolution\n    );\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    const sourceNumericalShiftX = x0;\n    const sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    const augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0],\n    ];\n    const affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n\n    if (isBrokenDiagonalRendering() || !interpolate) {\n      // Make sure that all lines are horizontal or vertical\n      context.moveTo(u1, v1);\n      // This is the diagonal line. Do it in 4 steps\n      const steps = 4;\n      const ud = u0 - u1;\n      const vd = v0 - v1;\n      for (let step = 0; step < steps; step++) {\n        // Go horizontally\n        context.lineTo(\n          u1 + pixelRound(((step + 1) * ud) / steps),\n          v1 + pixelRound((step * vd) / (steps - 1))\n        );\n        // Go vertically\n        if (step != steps - 1) {\n          context.lineTo(\n            u1 + pixelRound(((step + 1) * ud) / steps),\n            v1 + pixelRound(((step + 1) * vd) / (steps - 1))\n          );\n        }\n      }\n      // We are almost at u0r, v0r\n      context.lineTo(u2, v2);\n    } else {\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n    }\n\n    context.clip();\n\n    context.transform(\n      affineCoefs[0],\n      affineCoefs[2],\n      affineCoefs[1],\n      affineCoefs[3],\n      u0,\n      v0\n    );\n\n    context.translate(\n      sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY\n    );\n\n    let image;\n    if (stitchContext) {\n      image = stitchContext.canvas;\n      context.scale(\n        sourceResolution / pixelRatio,\n        -sourceResolution / pixelRatio\n      );\n    } else {\n      const source = sources[0];\n      const extent = source.extent;\n      image = source.image;\n      context.scale(\n        getWidth(extent) / image.width,\n        -getHeight(extent) / image.height\n      );\n    }\n\n    context.drawImage(image, 0, 0);\n    context.restore();\n  });\n\n  if (stitchContext) {\n    releaseCanvas(stitchContext);\n    canvasPool.push(stitchContext.canvas);\n  }\n\n  if (renderEdges) {\n    context.save();\n\n    context.globalCompositeOperation = 'source-over';\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function (triangle, i, arr) {\n      const target = triangle.target;\n      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n","/**\n * @module ol/resolution\n */\n\n/**\n * @typedef {number|Array<number>} ResolutionLike\n */\n\n/**\n * @param {ResolutionLike} resolution Resolution.\n * @return {number} Resolution.\n */\nexport function fromResolutionLike(resolution) {\n  if (Array.isArray(resolution)) {\n    return Math.min(...resolution);\n  }\n  return resolution;\n}\n","/**\n * @module ol/reproj/Image\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport ImageWrapper from '../Image.js';\nimport Triangulation from './Triangulation.js';\nimport {\n  calculateSourceResolution,\n  render as renderReprojected,\n} from '../reproj.js';\nimport {fromResolutionLike} from '../resolution.js';\nimport {\n  getCenter,\n  getHeight,\n  getIntersection,\n  getWidth,\n  isEmpty,\n} from '../extent.js';\nimport {listen, unlistenByKey} from '../events.js';\n\n/**\n * @typedef {function(import(\"../extent.js\").Extent, number, number) : import(\"../Image.js\").default} FunctionType\n */\n\n/**\n * @classdesc\n * Class encapsulating single reprojected image.\n * See {@link module:ol/source/Image~ImageSource}.\n */\nclass ReprojImage extends ImageWrapper {\n  /**\n   * @param {import(\"../proj/Projection.js\").default} sourceProj Source projection (of the data).\n   * @param {import(\"../proj/Projection.js\").default} targetProj Target projection.\n   * @param {import(\"../extent.js\").Extent} targetExtent Target extent.\n   * @param {number} targetResolution Target resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {FunctionType} getImageFunction\n   *     Function returning source images (extent, resolution, pixelRatio).\n   * @param {boolean} interpolate Use linear interpolation when resampling.\n   */\n  constructor(\n    sourceProj,\n    targetProj,\n    targetExtent,\n    targetResolution,\n    pixelRatio,\n    getImageFunction,\n    interpolate\n  ) {\n    let maxSourceExtent = sourceProj.getExtent();\n    if (maxSourceExtent && sourceProj.canWrapX()) {\n      maxSourceExtent = maxSourceExtent.slice();\n      maxSourceExtent[0] = -Infinity;\n      maxSourceExtent[2] = Infinity;\n    }\n    let maxTargetExtent = targetProj.getExtent();\n    if (maxTargetExtent && targetProj.canWrapX()) {\n      maxTargetExtent = maxTargetExtent.slice();\n      maxTargetExtent[0] = -Infinity;\n      maxTargetExtent[2] = Infinity;\n    }\n\n    const limitedTargetExtent = maxTargetExtent\n      ? getIntersection(targetExtent, maxTargetExtent)\n      : targetExtent;\n\n    const targetCenter = getCenter(limitedTargetExtent);\n    const sourceResolution = calculateSourceResolution(\n      sourceProj,\n      targetProj,\n      targetCenter,\n      targetResolution\n    );\n\n    const errorThresholdInPixels = ERROR_THRESHOLD;\n\n    const triangulation = new Triangulation(\n      sourceProj,\n      targetProj,\n      limitedTargetExtent,\n      maxSourceExtent,\n      sourceResolution * errorThresholdInPixels,\n      targetResolution\n    );\n\n    const sourceExtent = triangulation.calculateSourceExtent();\n    const sourceImage = isEmpty(sourceExtent)\n      ? null\n      : getImageFunction(sourceExtent, sourceResolution, pixelRatio);\n    const state = sourceImage ? ImageState.IDLE : ImageState.EMPTY;\n    const sourcePixelRatio = sourceImage ? sourceImage.getPixelRatio() : 1;\n\n    super(targetExtent, targetResolution, sourcePixelRatio, state);\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.targetProj_ = targetProj;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.maxSourceExtent_ = maxSourceExtent;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = triangulation;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.targetResolution_ = targetResolution;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.targetExtent_ = targetExtent;\n\n    /**\n     * @private\n     * @type {import(\"../Image.js\").default}\n     */\n    this.sourceImage_ = sourceImage;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourcePixelRatio_ = sourcePixelRatio;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.interpolate_ = interpolate;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {?import(\"../events.js\").EventsKey}\n     */\n    this.sourceListenerKey_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    if (this.state == ImageState.LOADING) {\n      this.unlistenSource_();\n    }\n    super.disposeInternal();\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image.\n   */\n  getImage() {\n    return this.canvas_;\n  }\n\n  /**\n   * @return {import(\"../proj/Projection.js\").default} Projection.\n   */\n  getProjection() {\n    return this.targetProj_;\n  }\n\n  /**\n   * @private\n   */\n  reproject_() {\n    const sourceState = this.sourceImage_.getState();\n    if (sourceState == ImageState.LOADED) {\n      const width = getWidth(this.targetExtent_) / this.targetResolution_;\n      const height = getHeight(this.targetExtent_) / this.targetResolution_;\n      this.canvas_ = renderReprojected(\n        width,\n        height,\n        this.sourcePixelRatio_,\n        fromResolutionLike(this.sourceImage_.getResolution()),\n        this.maxSourceExtent_,\n        this.targetResolution_,\n        this.targetExtent_,\n        this.triangulation_,\n        [\n          {\n            extent: this.sourceImage_.getExtent(),\n            image: this.sourceImage_.getImage(),\n          },\n        ],\n        0,\n        undefined,\n        this.interpolate_,\n        true\n      );\n    }\n    this.state = sourceState;\n    this.changed();\n  }\n\n  /**\n   * Load not yet loaded URI.\n   */\n  load() {\n    if (this.state == ImageState.IDLE) {\n      this.state = ImageState.LOADING;\n      this.changed();\n\n      const sourceState = this.sourceImage_.getState();\n      if (sourceState == ImageState.LOADED || sourceState == ImageState.ERROR) {\n        this.reproject_();\n      } else {\n        this.sourceListenerKey_ = listen(\n          this.sourceImage_,\n          EventType.CHANGE,\n          function (e) {\n            const sourceState = this.sourceImage_.getState();\n            if (\n              sourceState == ImageState.LOADED ||\n              sourceState == ImageState.ERROR\n            ) {\n              this.unlistenSource_();\n              this.reproject_();\n            }\n          },\n          this\n        );\n        this.sourceImage_.load();\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  unlistenSource_() {\n    unlistenByKey(\n      /** @type {!import(\"../events.js\").EventsKey} */ (this.sourceListenerKey_)\n    );\n    this.sourceListenerKey_ = null;\n  }\n}\n\nexport default ReprojImage;\n","/**\n * @module ol/source/common\n */\n\n/**\n * Default WMS version.\n * @type {string}\n */\nexport const DEFAULT_WMS_VERSION = '1.3.0';\n\n/**\n * Number of decimal digits to consider in integer values when rounding.\n * @type {number}\n */\nexport const DECIMALS = 4;\n","/**\n * @module ol/source/Image\n */\nimport Event from '../events/Event.js';\nimport EventType from '../events/EventType.js';\nimport ImageState from '../ImageState.js';\nimport ImageWrapper from '../Image.js';\nimport ReprojImage from '../reproj/Image.js';\nimport Source from './Source.js';\nimport {DECIMALS} from './common.js';\nimport {ceil} from '../math.js';\nimport {\n  containsExtent,\n  equals,\n  getCenter,\n  getForViewAndSize,\n  getHeight,\n  getWidth,\n} from '../extent.js';\nimport {equivalent} from '../proj.js';\nimport {fromResolutionLike} from '../resolution.js';\nimport {linearFindNearest} from '../array.js';\n\n/**\n * @enum {string}\n */\nexport const ImageSourceEventType = {\n  /**\n   * Triggered when an image starts loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadstart\n   * @api\n   */\n  IMAGELOADSTART: 'imageloadstart',\n\n  /**\n   * Triggered when an image finishes loading.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloadend\n   * @api\n   */\n  IMAGELOADEND: 'imageloadend',\n\n  /**\n   * Triggered if image loading results in an error.\n   * @event module:ol/source/Image.ImageSourceEvent#imageloaderror\n   * @api\n   */\n  IMAGELOADERROR: 'imageloaderror',\n};\n\n/**\n * @typedef {'imageloadend'|'imageloaderror'|'imageloadstart'} ImageSourceEventTypes\n */\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/source/Image~ImageSource} instances are instances of this\n * type.\n */\nexport class ImageSourceEvent extends Event {\n  /**\n   * @param {string} type Type.\n   * @param {import(\"../Image.js\").default} image The image.\n   */\n  constructor(type, image) {\n    super(type);\n\n    /**\n     * The image related to the event.\n     * @type {import(\"../Image.js\").default}\n     * @api\n     */\n    this.image = image;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types, import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<ImageSourceEventTypes, ImageSourceEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types\n *     |ImageSourceEventTypes, Return>} ImageSourceOnSignature\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"./Source.js\").AttributionLike} [attributions] Attributions.\n * @property {boolean} [interpolate=true] Use interpolated values when resampling.  By default,\n * linear interpolation is used when resampling.  Set to false to use the nearest neighbor instead.\n * @property {import(\"../Image.js\").Loader} [loader] Loader. Can either be a custom loader, or one of the\n * loaders created with a `createLoader()` function ({@link module:ol/source/wms.createLoader wms},\n * {@link module:ol/source/arcgisRest.createLoader arcgisRest}, {@link module:ol/source/mapguide.createLoader mapguide},\n * {@link module:ol/source/static.createLoader static}).\n * @property {import(\"../proj.js\").ProjectionLike} [projection] Projection.\n * @property {Array<number>} [resolutions] Resolutions.\n * @property {import(\"./Source.js\").State} [state] State.\n */\n\n/**\n * @classdesc\n * Base class for sources providing a single image.\n * @fires module:ol/source/Image.ImageSourceEvent\n * @api\n */\nclass ImageSource extends Source {\n  /**\n   * @param {Options} options Single image source options.\n   */\n  constructor(options) {\n    super({\n      attributions: options.attributions,\n      projection: options.projection,\n      state: options.state,\n      interpolate:\n        options.interpolate !== undefined ? options.interpolate : true,\n    });\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {ImageSourceOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {ImageSourceOnSignature<void>}\n     */\n    this.un;\n\n    /**\n     * @protected\n     * @type {import(\"../Image.js\").Loader}\n     */\n    this.loader = options.loader || null;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.resolutions_ =\n      options.resolutions !== undefined ? options.resolutions : null;\n\n    /**\n     * @private\n     * @type {import(\"../reproj/Image.js\").default}\n     */\n    this.reprojectedImage_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.reprojectedRevision_ = 0;\n\n    /**\n     * @protected\n     * @type {import(\"../Image.js\").default}\n     */\n    this.image = null;\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.wantedExtent_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.wantedResolution_;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.static_ = options.loader ? options.loader.length === 0 : false;\n\n    /**\n     * @private\n     * @type {import(\"../proj/Projection.js\").default}\n     */\n    this.wantedProjection_ = null;\n  }\n\n  /**\n   * @return {Array<number>|null} Resolutions.\n   */\n  getResolutions() {\n    return this.resolutions_;\n  }\n\n  /**\n   * @param {Array<number>|null} resolutions Resolutions.\n   */\n  setResolutions(resolutions) {\n    this.resolutions_ = resolutions;\n  }\n\n  /**\n   * @protected\n   * @param {number} resolution Resolution.\n   * @return {number} Resolution.\n   */\n  findNearestResolution(resolution) {\n    const resolutions = this.getResolutions();\n    if (resolutions) {\n      const idx = linearFindNearest(resolutions, resolution, 0);\n      resolution = resolutions[idx];\n    }\n    return resolution;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   */\n  getImage(extent, resolution, pixelRatio, projection) {\n    const sourceProjection = this.getProjection();\n    if (\n      !sourceProjection ||\n      !projection ||\n      equivalent(sourceProjection, projection)\n    ) {\n      if (sourceProjection) {\n        projection = sourceProjection;\n      }\n\n      return this.getImageInternal(extent, resolution, pixelRatio, projection);\n    }\n    if (this.reprojectedImage_) {\n      if (\n        this.reprojectedRevision_ == this.getRevision() &&\n        equivalent(this.reprojectedImage_.getProjection(), projection) &&\n        this.reprojectedImage_.getResolution() == resolution &&\n        equals(this.reprojectedImage_.getExtent(), extent)\n      ) {\n        return this.reprojectedImage_;\n      }\n      this.reprojectedImage_.dispose();\n      this.reprojectedImage_ = null;\n    }\n\n    this.reprojectedImage_ = new ReprojImage(\n      sourceProjection,\n      projection,\n      extent,\n      resolution,\n      pixelRatio,\n      (extent, resolution, pixelRatio) =>\n        this.getImageInternal(extent, resolution, pixelRatio, sourceProjection),\n      this.getInterpolate()\n    );\n    this.reprojectedRevision_ = this.getRevision();\n\n    return this.reprojectedImage_;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @param {number} resolution Resolution.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {import(\"../proj/Projection.js\").default} projection Projection.\n   * @return {import(\"../Image.js\").default} Single image.\n   * @protected\n   */\n  getImageInternal(extent, resolution, pixelRatio, projection) {\n    if (this.loader) {\n      const requestExtent = getRequestExtent(extent, resolution, pixelRatio, 1);\n      const requestResolution = this.findNearestResolution(resolution);\n      if (\n        this.image &&\n        (this.static_ ||\n          (this.wantedProjection_ === projection &&\n            ((this.wantedExtent_ &&\n              containsExtent(this.wantedExtent_, requestExtent)) ||\n              containsExtent(this.image.getExtent(), requestExtent)) &&\n            ((this.wantedResolution_ &&\n              fromResolutionLike(this.wantedResolution_) ===\n                requestResolution) ||\n              fromResolutionLike(this.image.getResolution()) ===\n                requestResolution)))\n      ) {\n        return this.image;\n      }\n      this.wantedProjection_ = projection;\n      this.wantedExtent_ = requestExtent;\n      this.wantedResolution_ = requestResolution;\n      this.image = new ImageWrapper(\n        requestExtent,\n        requestResolution,\n        pixelRatio,\n        this.loader\n      );\n      this.image.addEventListener(\n        EventType.CHANGE,\n        this.handleImageChange.bind(this)\n      );\n    }\n    return this.image;\n  }\n\n  /**\n   * Handle image change events.\n   * @param {import(\"../events/Event.js\").default} event Event.\n   * @protected\n   */\n  handleImageChange(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    let type;\n    switch (image.getState()) {\n      case ImageState.LOADING:\n        this.loading = true;\n        type = ImageSourceEventType.IMAGELOADSTART;\n        break;\n      case ImageState.LOADED:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADEND;\n        break;\n      case ImageState.ERROR:\n        this.loading = false;\n        type = ImageSourceEventType.IMAGELOADERROR;\n        break;\n      default:\n        return;\n    }\n    if (this.hasListener(type)) {\n      this.dispatchEvent(new ImageSourceEvent(type, image));\n    }\n  }\n}\n\n/**\n * Default image load function for image sources that use import(\"../Image.js\").Image image\n * instances.\n * @param {import(\"../Image.js\").default} image Image.\n * @param {string} src Source.\n */\nexport function defaultImageLoadFunction(image, src) {\n  /** @type {HTMLImageElement|HTMLVideoElement} */ (image.getImage()).src = src;\n}\n\n/**\n * Adjusts the extent so it aligns with pixel boundaries.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} resolution Reolution.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} ratio Ratio between request size and view size.\n * @return {import(\"../extent.js\").Extent} Request extent.\n */\nexport function getRequestExtent(extent, resolution, pixelRatio, ratio) {\n  const imageResolution = resolution / pixelRatio;\n  const center = getCenter(extent);\n  const viewWidth = ceil(getWidth(extent) / imageResolution, DECIMALS);\n  const viewHeight = ceil(getHeight(extent) / imageResolution, DECIMALS);\n  const marginWidth = ceil(((ratio - 1) * viewWidth) / 2, DECIMALS);\n  const requestWidth = viewWidth + 2 * marginWidth;\n  const marginHeight = ceil(((ratio - 1) * viewHeight) / 2, DECIMALS);\n  const requestHeight = viewHeight + 2 * marginHeight;\n  return getForViewAndSize(center, imageResolution, 0, [\n    requestWidth,\n    requestHeight,\n  ]);\n}\n\nexport default ImageSource;\n"],"names":["ERROR_THRESHOLD","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","Triangulation","sourceProj","targetProj","targetExtent","maxSourceExtent","errorThreshold","destinationResolution","transformInvCache","transformInv","getTransform","c","key","getWidth","destinationTopLeft","getTopLeft","destinationTopRight","getTopRight","destinationBottomRight","getBottomRight","destinationBottomLeft","getBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","maxSubdivision","getArea","leftBound","triangle","i","arr","newTriangle","minX","a","b","aSrc","bSrc","cSrc","d","dSrc","sourceQuadExtent","boundingExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","targetQuadExtent","intersects","isNotFinite","center","centerSrc","dx","modulo","dy","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","extent","createEmpty","src","extendCoordinate","Triangulation$1","brokenDiagonalRendering_","canvasPool","drawTestTriangle","ctx","u1","v1","u2","v2","verifyBrokenDiagonalRendering","data","offset","isBrokenDiagonalRendering","createCanvasContext2D","releaseCanvas","calculateSourceResolution","targetCenter","targetResolution","sourceCenter","transform","sourceResolution","getPointResolution","targetMetersPerUnit","sourceMetersPerUnit","sourceExtent","containsCoordinate","compensationFactor","calculateSourceExtentResolution","getCenter","forEachCorner","corner","render","width","height","pixelRatio","triangulation","sources","gutter","renderEdges","interpolate","drawSingle","context","pixelRound","value","sourceDataExtent","extend","stitchContext","canvasWidthInUnits","canvasHeightInUnits","getHeight","stitchScale","xPos","yPos","srcWidth","srcHeight","targetTopLeft","source","target","x0","y0","x1","y1","x2","y2","u0","v0","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","solveLinearSystem","steps","ud","vd","step","image","fromResolutionLike","resolution","ReprojImage","ImageWrapper","getImageFunction","maxTargetExtent","limitedTargetExtent","getIntersection","errorThresholdInPixels","sourceImage","isEmpty","state","ImageState","sourcePixelRatio","sourceState","renderReprojected","listen","EventType","e","unlistenByKey","ReprojImage$1","DECIMALS","ImageSourceEventType","ImageSourceEvent","Event","type","ImageSource","Source","options","resolutions","idx","linearFindNearest","projection","sourceProjection","equivalent","equals","requestExtent","getRequestExtent","requestResolution","containsExtent","event","defaultImageLoadFunction","ratio","imageResolution","viewWidth","ceil","viewHeight","marginWidth","requestWidth","marginHeight","requestHeight","getForViewAndSize","ImageSource$1"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}